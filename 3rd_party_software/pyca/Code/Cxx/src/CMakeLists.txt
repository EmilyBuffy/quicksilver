INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR})

SET(PYCA_SRC
  alg/CFluidKernelFFT.cxx
  alg/FluidKernelFFTBase.cxx
  alg/GaussianFilterBase.cxx
  alg/GaussRecFilterBase.cxx
  alg/GaussUtils.cxx
  alg/MultiscaleManager.cxx
  alg/MultiscaleResampler.cxx

  base/CReduce.cxx
  base/CudaUtils.cxx
  base/DownSampleParamUtils.cxx
  base/GaussParamUtils.cxx
  base/MemoryManager.cxx
  base/Reduce.cxx
  base/StringUtils.cxx
  base/PyCAThread.cxx

  math/FieldOpers.cxx
  math/HFieldOpers.cxx
  math/ImageFieldOpers.cxx
  math/ReduceOb.cxx
  math/Reduction.cxx
  math/VFieldOpers.cxx
  math/CFieldOpers.cxx
  math/CFiniteDiff.cxx
  math/CHFieldOpers.cxx
  math/CImageFieldOpers.cxx
  math/CImageOpers.cxx
  math/CVFieldOpers.cxx
  math/CMemOpers.cxx
  math/MemOpers.cxx
  math/FOpers.cxx
  math/HFOpers.cxx
  math/IOpers.cxx
  math/IFOpers.cxx
  math/ImageOpers.cxx
  math/VFOpers.cxx

  thread/ThreadIdentity.cxx

  types/Array.cxx
  types/Field3D.cxx
  types/Image3D.cxx
  types/estream.cxx
  types/mem.cxx
  types/MemPool.cxx
  types/Mat3D.cxx
  types/Aff3D.cxx
)

IF(CUDA_ENABLED)
  CUDA_INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR})

  SET(PYCA_SRC
    ${PYCA_SRC}
    alg/GFluidKernelFFTKernels.cu
    alg/GFluidKernelFFT.cxx
    alg/GGaussianFilter.cxx
    alg/GGaussRecFilterKernels.cu
    alg/GGaussRecFilter.cxx
    alg/GGaussUtils.cu
    
    base/GReduce.cu
    base/GReduceStream.cu
    
    math/GSplat.cu
    math/GFieldOperKernels.cu
    math/GFieldOpers.cxx
    math/GHFieldOperKernels.cu
    math/GHFieldOpers.cxx
    math/GImageFieldOperKernels.cu
    math/GImageFieldOpers.cxx
    math/GImageOperKernels.cu
    math/GImageOpers.cxx
    math/GVFieldOperKernels.cu
    math/GVFieldOpers.cxx
    math/GMemOpers.cu
    
    types/gmem.cu
    )
ENDIF(CUDA_ENABLED)

IF(ITK_FOUND)
  SET(PYCA_SRC
    ${PYCA_SRC}
    io/ITKFileIO.cxx
    )
ENDIF(ITK_FOUND)

SET(TPL_SRC
  base/Reduce_inst.tpl

  math/IOpers_inst.tpl
  math/ImageOpers_inst.tpl
  math/GImageOpers_inst.tpl
  math/GImageOperKernels_inst.tpl
  math/CImageOpers_inst.tpl
  math/IFOpers_inst.tpl
  math/ImageFieldOpers_inst.tpl
  math/GImageFieldOpers_inst.tpl
  math/GImageFieldOperKernels_inst.tpl
  math/CImageFieldOpers_inst.tpl
  math/FOpers_inst.tpl
  math/FieldOpers_inst.tpl
  math/GFieldOpers_inst.tpl
  math/GFieldOperKernels_inst.tpl
  math/HFOpers_inst.tpl
  math/HFieldOpers_inst.tpl
  math/VFOpers_inst.tpl
  math/VFieldOpers_inst.tpl
  math/ReduceOb_inst.tpl
  )

# 
# For bla_inst.tpl in TPL_SRC, a bla_inst.tpl.proc (TPL_PROC_FILE)
# will be generated by running bla_inst.tpl through the c
# preprocessor.  Then a bla_inst.cxx (TPL_CXX_FILE) will be generated
# via python script.  Then this cxx file will be added as a dependency
# of bla.cxx (TPL_DEP_CXX)
FOREACH(IN_TPL_FILE IN LISTS TPL_SRC)
  GET_FILENAME_COMPONENT(TPL_FILE ${IN_TPL_FILE} ABSOLUTE)
  GET_FILENAME_COMPONENT(TPL_FILE_BASE ${TPL_FILE} NAME_WE)
  SET(TPL_PROC_FILE ${CMAKE_CURRENT_BINARY_DIR}/${TPL_FILE_BASE}.tpl.proc)
  SET(TPL_CXX_FILE ${CMAKE_CURRENT_BINARY_DIR}/${TPL_FILE_BASE}.cxx)
  STRING(REGEX MATCH "(.*)_inst.tpl" TPL_DEP_CXX_BASE ${TPL_FILE})
  IF(TPL_DEP_CXX_BASE)
    # SET(TPL_DEP_CXX ${CMAKE_MATCH_1}.cxx)
    FILE(GLOB TPL_DEP_CXX ${CMAKE_MATCH_1}.cu ${CMAKE_MATCH_1}.cxx)
    IF(TPL_DEP_CXX)
      LIST(GET TPL_DEP_CXX 0 TPL_DEP_CXX)
    ELSE(TPL_DEP_CXX)
      MESSAGE(WARNING "Could not find CXX/CU dependency for ${IN_TPL_FILE}")
    ENDIF(TPL_DEP_CXX)
    GET_FILENAME_COMPONENT(TPL_DEP_CXX_EXT ${TPL_DEP_CXX} EXT)
  ELSE(TPL_DEP_CXX_BASE)
    MESSAGE(WARNING "Dependency name could not be generated from ${TPL_FILE}, should have ended in _inst.tpl")
  ENDIF(TPL_DEP_CXX_BASE)

  GET_DIRECTORY_PROPERTY(COMPILER_DEFS COMPILE_DEFINITIONS)
  SET(DEF_FLAGS)
  FOREACH(CDEF IN LISTS COMPILER_DEFS)
    SET(DEF_FLAGS "${DEF_FLAGS};-D${CDEF}")
  ENDFOREACH(CDEF)
  #MESSAGE(STATUS "Compiler Defs: ${DEF_FLAGS}")

  IF(CMAKE_CXX_COMPILER_ID STREQUAL "GNU" OR
      CMAKE_CXX_COMPILER_ID STREQUAL "Clang" OR
      CMAKE_CXX_COMPILER_ID STREQUAL "Intel")
    ADD_CUSTOM_COMMAND(
      OUTPUT ${TPL_PROC_FILE}
      # TODO: Need to find cpp using cmake instead of assuming it's in $PATH
      COMMAND ${CMAKE_CXX_COMPILER} ${DEF_FLAGS} -E -x c ${TPL_FILE} -o ${TPL_PROC_FILE}
      MAIN_DEPENDENCY ${TPL_FILE}
      VERBATIM)
  ELSEIF(MSVC)
    ADD_CUSTOM_COMMAND(
      OUTPUT ${TPL_PROC_FILE}
      # TODO: Need to find cpp using cmake instead of assuming it's in $PATH
      COMMAND ${CMAKE_CXX_COMPILER} ${DEF_FLAGS} /P ${TPL_FILE} /Fi${TPL_PROC_FILE}
      MAIN_DEPENDENCY ${TPL_FILE}
      VERBATIM)
  ELSE()
      MESSAGE(FATAL_ERROR "Compiler/OS not recognized.  Cannot decide how to generate .proc files from .tpl files.")
  ENDIF()

  ADD_CUSTOM_COMMAND(
    OUTPUT ${TPL_CXX_FILE}
    COMMAND ${PYTHON_EXECUTABLE} ${PyCA_SOURCE_DIR}/Code/TemplateParse.py 
    ${TPL_PROC_FILE} ${TPL_CXX_FILE}
    MAIN_DEPENDENCY ${TPL_PROC_FILE}
    VERBATIM)

  IF(TPL_DEP_CXX_EXT STREQUAL ".cu")

    # Can't use standard dependency rules with .cu files, as these are
    # handled by FindCUDA.cmake and don't process standard
    # dependencies correctly.  Instead these will be added to a custom
    # target.
    LIST(APPEND CUDA_TPL_CXX_FILES ${TPL_CXX_FILE})

  ELSE(TPL_DEP_CXX_EXT STREQUAL ".cu")
    
    # Add dependency of bla.cxx on bla_inst.cxx
    IF(TPL_DEP_CXX)
      IF(EXISTS ${TPL_DEP_CXX})
	GET_SOURCE_FILE_PROPERTY(CUR_OBJ_DEPS ${TPL_DEP_CXX} OBJECT_DEPENDS)
	IF(CUR_OBJ_DEPS)
	  SET(CUR_OBJ_DEPS "${CUR_OBJ_DEPS};${TPL_CXX_FILE}")
	ELSE(CUR_OBJ_DEPS)
	  SET(CUR_OBJ_DEPS ${TPL_CXX_FILE})
	ENDIF(CUR_OBJ_DEPS)
	SET_SOURCE_FILES_PROPERTIES(${TPL_DEP_CXX} PROPERTIES OBJECT_DEPENDS "${CUR_OBJ_DEPS}")
      ELSE(EXISTS ${TPL_DEP_CXX})
	MESSAGE(WARNING "Dependency file ${TPL_DEP_CXX} for generated file ${TPL_CXX_FILE} does not exist")
      ENDIF(EXISTS ${TPL_DEP_CXX})
    ELSE(TPL_DEP_CXX)
      MESSAGE(WARNING "TPL_DEP_CXX does not exist")
    ENDIF(TPL_DEP_CXX)
  ENDIF(TPL_DEP_CXX_EXT STREQUAL ".cu")

ENDFOREACH(IN_TPL_FILE)

# Custom target which will be added as dependency of PyCA library.
# This ensures generation of bla_inst.cxx from bla_inst.tpl *before*
# cuda compilation
ADD_CUSTOM_TARGET(CUDA_TPL_DEPS
  DEPENDS ${CUDA_TPL_CXX_FILES}
  COMMENT "Running CUDA_TPL_DEPS"
  )

IF(CUDA_ENABLED)
  CUDA_ADD_LIBRARY(PyCA
    ${LIBTYPE}
    ${PYCA_SRC}
    OPTIONS ${CUDA_OPTS}
    )
ELSE(CUDA_ENABLED)
  ADD_LIBRARY(PyCA
    ${LIBTYPE}
    ${PYCA_SRC}
    )
ENDIF(CUDA_ENABLED)

ADD_DEPENDENCIES(PyCA CUDA_TPL_DEPS)

IF(WRAP_PYTHON)
  # needed since this lib is linked with shared lib for python 
  # wrapping
  # Note that -fPIC has to be added to nvcc options too for nvcc
  # compiled code
  SET_TARGET_PROPERTIES(PyCA PROPERTIES COMPILE_FLAGS -fPIC)
ENDIF(WRAP_PYTHON)

SET(PyCA_LIBS
  ${FFTWF_LIB}
  ${FFTWD_LIB}
  )

IF(ENABLE_ITK)
  SET(PyCA_LIBS
    ${PyCA_LIBS}
    ${ITK_LIBRARIES}
    )
ENDIF(ENABLE_ITK)

IF(CUDA_ENABLED)
  SET(PyCA_LIBS
    ${PyCA_LIBS}
    ${CUDA_LIBRARIES}
    ${CUFFT_LIBRARIES}
    )
ENDIF(CUDA_ENABLED)

TARGET_LINK_LIBRARIES(PyCA
  ${PyCA_LIBS}
  )

